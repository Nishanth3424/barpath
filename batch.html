<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Batch - Barpath Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script>tailwind.config = { darkMode: 'class' }</script>
    <style>
        :root { --glass-border: rgba(255, 255, 255, 0.1); --glass-bg: rgba(20, 20, 25, 0.7); }
        body { font-family: -apple-system, sans-serif; background: #000; color: white; overflow-x: hidden; }
        .mesh-bg { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: radial-gradient(circle at 50% 100%, #1a237e 0%, #000000 70%); z-index: -1; }
        .glass-panel { background: var(--glass-bg); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border: 1px solid var(--glass-border); }
    </style>
</head>
<body class="pb-24">
    <div class="mesh-bg"></div>

    <div class="max-w-lg mx-auto px-6 py-8">
        <div class="flex items-center gap-4 mb-8">
            <button onclick="window.location.href='index.html'" class="p-3 rounded-full hover:bg-white/10 glass-panel">
                <i data-lucide="arrow-left" class="w-6 h-6"></i>
            </button>
            <h1 class="text-2xl font-bold tracking-tight">Batch Analysis</h1>
        </div>

        <div class="glass-panel p-4 rounded-2xl mb-6 flex gap-3 items-start border-blue-500/30 bg-blue-900/10">
            <i data-lucide="database" class="w-5 h-5 text-blue-400 mt-0.5"></i>
            <div class="text-sm text-blue-200">
                <strong>Unlimited Storage Active:</strong> All videos and graphs will be saved to your device history until disk is full.
            </div>
        </div>

        <div onclick="document.getElementById('batchInput').click()" class="glass-panel border-dashed border-2 border-white/20 rounded-[32px] p-8 text-center cursor-pointer hover:bg-white/5 transition-all mb-8">
            <input type="file" id="batchInput" multiple accept="video/*" class="hidden">
            <div class="w-16 h-16 mx-auto mb-4 rounded-full bg-purple-600/20 flex items-center justify-center">
                <i data-lucide="copy-plus" class="w-8 h-8 text-purple-400"></i>
            </div>
            <p class="font-bold text-lg mb-1">Select Multiple Videos</p>
            <p class="text-xs text-gray-500">Queue them up for auto-processing</p>
        </div>

        <button id="processBtn" onclick="processQueue()" disabled class="w-full py-4 bg-gray-800 text-gray-500 font-bold rounded-2xl transition-all shadow-lg mb-8 flex items-center justify-center gap-2">
            Waiting for videos...
        </button>

        <div id="queueList" class="space-y-3"></div>
    </div>

    <div id="successModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/80 hidden opacity-0 transition-opacity duration-300">
        <div class="glass-panel p-8 rounded-3xl text-center max-w-xs mx-4 transform scale-95 transition-transform duration-300" id="modalContent">
            <div class="w-16 h-16 bg-green-500 rounded-full flex items-center justify-center mx-auto mb-4 shadow-[0_0_20px_rgba(34,197,94,0.5)]">
                <i data-lucide="check" class="w-8 h-8 text-black font-bold"></i>
            </div>
            <h2 class="text-xl font-bold mb-2">Batch Complete!</h2>
            <p class="text-gray-400 text-sm mb-6">All videos have been analyzed and saved.</p>
            <button onclick="window.location.href='history.html'" class="w-full py-3 bg-white text-black font-bold rounded-xl hover:bg-gray-200 transition-colors">
                Check History
            </button>
        </div>
    </div>

    <script>
        lucide.createIcons();
        const API_URL = 'https://gamercheetah24--barpath-analyzer-v2-web.modal.run/api';
        let queue = [];
        let isProcessing = false;
        
        // Use DB Version 3 to match other files
        function openDB(){return new Promise((r,j)=>{const q=indexedDB.open("BarpathDB",3);q.onsuccess=e=>r(e.target.result);q.onerror=e=>j(e)})}

        document.getElementById('batchInput').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                queue.push({ id: Math.random().toString(36).substr(2,9), file, status: 'pending', error: null });
            });
            renderQueue();
            updateProcessBtn();
        });

        function renderQueue() {
            const list = document.getElementById('queueList');
            if (queue.length === 0) { list.innerHTML = `<div class="text-center text-gray-600 text-sm">Queue is empty</div>`; return; }
            
            list.innerHTML = queue.map((item, index) => `
                <div class="glass-panel p-4 rounded-xl flex items-center justify-between">
                    <div class="flex items-center gap-3 overflow-hidden">
                        <div class="w-8 h-8 rounded-full flex items-center justify-center ${getStatusColor(item.status)} bg-opacity-20">
                            ${getStatusIcon(item.status)}
                        </div>
                        <div class="min-w-0">
                            <div class="font-medium text-sm truncate w-40">${item.file.name}</div>
                            <div class="text-[10px] uppercase font-bold tracking-wider ${getStatusTextColor(item.status)}">${item.status}</div>
                        </div>
                    </div>
                    ${item.status === 'pending' && !isProcessing ? `<button onclick="removeFromQueue(${index})" class="p-2 hover:bg-white/10 rounded-full"><i data-lucide="x" class="w-4 h-4 text-gray-400"></i></button>` : ''}
                </div>
            `).join('');
            lucide.createIcons();
        }

        function getStatusColor(s) { return s==='pending'?'bg-gray-500':s==='processing'?'bg-blue-500 animate-pulse':s==='complete'?'bg-green-500':'bg-red-500'; }
        function getStatusTextColor(s) { return s==='pending'?'text-gray-500':s==='processing'?'text-blue-400':s==='complete'?'text-green-400':'text-red-400'; }
        function getStatusIcon(s) {
            if(s==='pending') return '<div class="w-2 h-2 bg-gray-400 rounded-full"></div>';
            if(s==='processing') return '<i data-lucide="loader-2" class="w-4 h-4 text-blue-400 animate-spin"></i>';
            if(s==='complete') return '<i data-lucide="check" class="w-4 h-4 text-green-400"></i>';
            return '<i data-lucide="alert-circle" class="w-4 h-4 text-red-400"></i>';
        }

        function removeFromQueue(i) { queue.splice(i, 1); renderQueue(); updateProcessBtn(); }

        function updateProcessBtn() {
            const btn = document.getElementById('processBtn');
            const pending = queue.filter(i => i.status === 'pending').length;
            if (isProcessing) {
                btn.textContent = "Processing...";
                btn.className = "w-full py-4 bg-blue-600/50 text-white font-bold rounded-2xl cursor-wait";
                btn.disabled = true;
            } else if (pending > 0) {
                btn.textContent = `Start Batch (${pending})`;
                btn.className = "w-full py-4 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-2xl shadow-lg shadow-purple-900/50";
                btn.disabled = false;
            } else {
                btn.textContent = "Add Videos to Start";
                btn.className = "w-full py-4 bg-gray-800 text-gray-500 font-bold rounded-2xl";
                btn.disabled = true;
            }
        }

        function readFile(file) {
            return new Promise((resolve) => {
                const r = new FileReader();
                r.onload = () => resolve(r.result.split(',')[1]);
                r.readAsDataURL(file);
            });
        }

        async function processQueue() {
            if (isProcessing) return;
            isProcessing = true;
            updateProcessBtn();

            for (let i = 0; i < queue.length; i++) {
                if (queue[i].status !== 'pending') continue;
                queue[i].status = 'processing';
                renderQueue();

                try {
                    const b64 = await readFile(queue[i].file);
                    const res = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ video: b64, lift_type: 'clean', filename: queue[i].file.name })
                    });
                    const data = await res.json();

                    if (data.success) {
                        const liftId = Date.now() + i;
                        
                        // 1. SAVE TO DB (HEAVY)
                        const db = await openDB();
                        const tx = db.transaction(["videos", "graphs"], "readwrite");
                        if (data.rendered_video) tx.objectStore("videos").put(data.rendered_video, liftId);
                        if (data.graphs) tx.objectStore("graphs").put(data.graphs, liftId);
                        await new Promise(r => { tx.oncomplete = r; tx.onerror = r; });

                        // 2. SAVE TO HISTORY (LIGHT)
                        const history = JSON.parse(localStorage.getItem('liftHistory') || '[]');
                        const lightResult = { ...data };
                        delete lightResult.rendered_video; 
                        delete lightResult.graphs;         

                        history.unshift({
                            id: liftId,
                            date: new Date().toISOString(),
                            lift: 'clean',
                            score: Math.round(data.metrics?.technique_score || 0),
                            velocity: Math.round(data.metrics?.peak_velocity || 0),
                            duration: (data.metrics?.duration || 0).toFixed(1),
                            resultData: lightResult
                        });
                        localStorage.setItem('liftHistory', JSON.stringify(history.slice(0, 20)));
                        
                        queue[i].status = 'complete';
                    } else {
                        queue[i].status = 'error';
                    }
                } catch (e) {
                    queue[i].status = 'error';
                }
                renderQueue();
            }
            isProcessing = false;
            updateProcessBtn();
            
            if (queue.every(q => q.status === 'complete')) {
                const modal = document.getElementById('successModal');
                const content = document.getElementById('modalContent');
                modal.classList.remove('hidden');
                setTimeout(() => {
                    modal.classList.remove('opacity-0');
                    content.classList.remove('scale-95');
                    content.classList.add('scale-100');
                }, 10);
            }
        }
    </script>
</body>
</html>